# -*- coding: utf-8 -*-
"""WLTech.Ai solves ARC Challenge (2024-10).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-rQoqrGRGQE6M8bMpfzqf6tV3TnUi-Mp
"""

!pip install -qU anthropic pydantic openai

from google.colab import userdata
ANTHROPIC_API_KEY = userdata.get('ANTHROPIC_API_KEY')
OPENAI_API_KEY = userdata.get('OPENAI_API_KEY')

import json

def load_tasks(challenges_file: str, solutions_file: str):
  with open(challenges_file, "r") as tasks:
    challenges = json.load(tasks)

  with open(solutions_file, "r") as tasks:
    solutions = json.load(tasks)

  return challenges, solutions

try:
  challenges, solutions = load_tasks(
      challenges_file='arc-agi_training_challenges.json',
      solutions_file='arc-agi_training_solutions.json'
      )

  challenge_ids = list(challenges.keys())
  challenge0 = challenges[challenge_ids[0]]
  solution0 = solutions[challenge_ids[0]]
except:
  challenge0 = {"test": [{"input": [[7, 0, 7], [7, 0, 7], [7, 7, 0]]}], "train": [{"input": [[0, 7, 7], [7, 7, 7], [0, 7, 7]], "output": [[0, 0, 0, 0, 7, 7, 0, 7, 7], [0, 0, 0, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 7, 7, 0, 7, 7], [0, 7, 7, 0, 7, 7, 0, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7], [0, 7, 7, 0, 7, 7, 0, 7, 7], [0, 0, 0, 0, 7, 7, 0, 7, 7], [0, 0, 0, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 7, 7, 0, 7, 7]]}, {"input": [[4, 0, 4], [0, 0, 0], [0, 4, 0]], "output": [[4, 0, 4, 0, 0, 0, 4, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]]}, {"input": [[0, 0, 0], [0, 0, 2], [2, 0, 2]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 2], [2, 0, 2, 0, 0, 0, 2, 0, 2]]}, {"input": [[6, 6, 0], [6, 0, 0], [0, 6, 6]], "output": [[6, 6, 0, 6, 6, 0, 0, 0, 0], [6, 0, 0, 6, 0, 0, 0, 0, 0], [0, 6, 6, 0, 6, 6, 0, 0, 0], [6, 6, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 0, 6, 6, 0], [0, 0, 0, 6, 0, 0, 6, 0, 0], [0, 0, 0, 0, 6, 6, 0, 6, 6]]}, {"input": [[2, 2, 2], [0, 0, 0], [0, 2, 2]], "output": [[2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 2, 2]]}]}
  solution0 = [[[7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 7, 0, 0, 0, 0, 7, 7, 0], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 0, 7, 0, 0, 0, 7, 0, 7], [7, 7, 0, 0, 0, 0, 7, 7, 0], [7, 0, 7, 7, 0, 7, 0, 0, 0], [7, 0, 7, 7, 0, 7, 0, 0, 0], [7, 7, 0, 7, 7, 0, 0, 0, 0]]]

from IPython.display import HTML, display
import matplotlib.pyplot as plt
import numpy as np
import io
import base64

def challengeset2gridb64(challengeset, prefix=''):
    n_examples = len(challengeset)

    # Check if the first example has an output
    has_output = 'output' in challengeset[0]
    n_cols = 2 if has_output else 1

    # Create figure with appropriate number of columns
    fig, axes = plt.subplots(n_examples, n_cols, figsize=(6*n_cols, 4*n_examples))

    # Ensure axes is always a 2D numpy array
    if n_examples == 1:
        if has_output:
            axes = np.array([axes])
        else:
            axes = np.array([[axes]])

    # Create a colormap with 17 distinct colors (0-16)
    colors = plt.cm.tab20(np.linspace(0, 1, 17))

    for idx, example in enumerate(challengeset):
        input_grid = example['input']
        rows, cols = len(input_grid), len(input_grid[0])

        # Plot input grid
        axes[idx, 0].imshow(input_grid, cmap='tab20', vmin=0, vmax=16)
        axes[idx, 0].grid(True)
        axes[idx, 0].set_title(f'{prefix}Input Grid {idx+1}')

        # Add value annotations for input grid
        for i in range(rows):
            for j in range(cols):
                axes[idx, 0].text(j, i, str(input_grid[i][j]),
                                ha='center', va='center', color='black')

        # Plot output grid if it exists
        if has_output:
            output_grid = example['output']
            out_rows, out_cols = len(output_grid), len(output_grid[0])

            axes[idx, 1].imshow(output_grid, cmap='tab20', vmin=0, vmax=16)
            axes[idx, 1].grid(True)
            axes[idx, 1].set_title(f'{prefix}Output Grid {idx+1}')

            # Add value annotations for output grid
            for i in range(out_rows):
                for j in range(out_cols):
                    axes[idx, 1].text(j, i, str(output_grid[i][j]),
                                    ha='center', va='center', color='black')

    plt.tight_layout()

    # Save plot to bytes buffer as JPEG
    buf = io.BytesIO()
    plt.savefig(buf, format='jpeg', bbox_inches='tight', dpi=100)
    plt.close()

    # Get the byte string
    buf.seek(0)
    img_bytes = buf.getvalue()

    # Encode to base64
    base64_string = base64.b64encode(img_bytes).decode('utf-8')

    return base64_string

def visualize_challenge(challengeset, prefix=''):
    """
    Visualizes a challenge set containing input (and optionally output) grids.

    Args:
        challengeset (list): List of dictionaries containing 'input' and optionally 'output' grids
        prefix (str): Optional prefix for grid titles
    """
    base64_string = challengeset2gridb64(challengeset, prefix)
    display(HTML(f'<img src="data:image/png;base64,{base64_string}"/>'))

visualize_challenge(challenge0['train'])

visualize_challenge(challenge0['test'], prefix='Challenge ')

"""### Explanation

It is quite easy for a human to recognize the pattern.  
Here, the task is to scale up the pattern in the input grid (3x3) to the pattern in the output grid (9x9) by applying the same input pattern to the subgrids of the output for non-zero cells.

- The input is a 3x3 grid with certain non-zero cells containing the non-negative integers.
- The output is a 9x9 grid.
- For each non-zero cell in the input grid, replicate the entire input pattern (3x3 grid) into the corresponding subgrid (of size 3x3) in the output grid.
- If a cell in the input grid contains zero, its corresponding subgrid in the output will remain filled with zeros.

In essence, non-zero values in the input act as "seeds" for copying the pattern into specific locations in the larger grid.
"""

def human_solve_challenge0(trainset, challenge):
    """
    Solves the grid transformation puzzle using the human-discovered algorithm.

    Args:
        trainset: List of training examples (not used in this implementation)
        challenge: Input grid to transform

    Returns:
        list: 9x9 output grid
    """
    # Initialize 9x9 output grid with zeros
    output_grid = [[0 for _ in range(9)] for _ in range(9)]

    # Function to get the starting indices for each subgrid
    def get_subgrid_start(i, j):
        return i * 3, j * 3

    # For each cell in the input grid
    for i in range(3):
        for j in range(3):
            # If the cell has a non-zero value
            if challenge[i][j] != 0:
                # Get the starting position of the corresponding subgrid
                start_row, start_col = get_subgrid_start(i, j)

                # Copy the input pattern into the subgrid
                for sub_i in range(3):
                    for sub_j in range(3):
                        output_grid[start_row + sub_i][start_col + sub_j] = challenge[sub_i][sub_j]

    return output_grid

human_solution = human_solve_challenge0(challenge0['train'], challenge0['test'][0]['input'])
assert human_solution == solution0[0]
visualize_challenge([{'input': challenge0['test'][0]['input'], 'output': human_solution}], prefix='Challenge ')

import anthropic
from openai import OpenAI
import re
import json
import time
import random
import hashlib


def build_examples_block(challengeset):
  blocks = []
  for block in challengeset:
    input_height = len(block['input'])
    input_width = len(block['input'][0])
    output_height = len(block['output'])
    output_width = len(block['output'][0])
    blocks.append(f"""<example>
Input Grid({input_height}x{input_width}):
```json
{block['input']}
```
Output Grid({output_height}x{output_width}):
```json
{block['output']}
```
</example>"""
  .replace('], ','],\n')
  .replace('[[','[\n[')
  .replace(']]',']\n]'))
  return "\n\n".join(blocks)


def extract_code_block(text):
    """
    Extracts the last Python code block from text marked with ```python ``` or ``` markers.

    Args:
        text (str): Input text containing Python code blocks

    Returns:
        str: The code content from the last Python code block, or None if no valid block is found
    """
    # Pattern to match code blocks with optional 'python' identifier
    pattern = r"```(?:python)?\s*(.*?)```"

    # Find all matches in the text, using re.DOTALL to match across lines
    matches = re.findall(pattern, text, re.DOTALL)

    if not matches:
        return None

    # Return the last code block found, stripped of leading/trailing whitespace
    return matches[-1].strip()


def extract_json_array(text):
    """
    Extracts the last JSON array from text that contains analysis and explanation.
    The function looks for patterns matching a 2D array notation.

    Args:
        text (str): Input text containing JSON array

    Returns:
        list: 2D list representing the extracted array, or None if no valid array is found
    """
    # Pattern to match JSON-like array with specific format:
    # [[x, y, z], [a, b, c], ...]
    pattern = r'\[\s*\[(?:\s*\d+\s*,\s*)*\d+\s*\](?:\s*,\s*\[(?:\s*\d+\s*,\s*)*\d+\s*\])*\s*\]'

    # Find all matches in the text
    matches = re.findall(pattern, text)

    if not matches:
        return None

    try:
        # Take the last match and parse it as JSON
        array_str = matches[-1]
        return json.loads(array_str)
    except json.JSONDecodeError:
        return None


def run_transform(transform_code, input_grid):
    """
    Executes transform function on input grid

    Args:
        transform_code (str): String containing transform function definition
        input_grid (List[List[int]]): Input grid to transform

    Returns:
        List[List[int]]: Transformed output grid
    """
    # Create namespace for execution
    namespace = {}

    # Execute the transform function definition
    exec(transform_code, namespace)

    # Get the transform function from namespace
    transform_func = namespace['transform']

    # Run transform on input
    return transform_func(input_grid)


def build_eval_block(challengeset, transform_code):
    blocks = []
    total_diff_cnt = 0
    # Create a string to store all diff maps for hashing
    all_diff_maps = []

    for block in challengeset:
        actual_output = run_transform(transform_code, block['input'])
        height = len(block['output'])
        width = len(block['output'][0])
        diff_cnt = height * width
        diff_map = [['n' for x in range(width)] for y in range(height)]

        for i in range(height):
            for j in range(width):
                if actual_output[i][j] == block['output'][i][j]:
                    diff_map[i][j] = 'y'
                    diff_cnt -= 1

        # Add diff_map to collection for hashing
        all_diff_maps.append(diff_map)
        total_diff_cnt += diff_cnt

        blocks.append(f"""<eval>
Input Grid:
```json
{block['input']}
```
Expected Output Grid:
```json
{block['output']}
```
Actual Output Grid:
```json
{actual_output}
```
Diff map (y - match, n - not match):
```json
{diff_map}
```
Status: {'Match' if diff_cnt == 0 else 'No match'}
Diff score (0 - perfect): {diff_cnt}
</eval>"""
        .replace('], ','],\n')
        .replace('[[','[\n[')
        .replace(']]',']\n]')
        )

    # Create a hash from all diff maps
    diff_maps_str = str(all_diff_maps).encode('utf-8')
    solution_hash = hashlib.md5(diff_maps_str).hexdigest()

    # Add the hash to the first block
    blocks[0] = blocks[0].replace("</eval>", f"\nSolution Hash: {solution_hash}</eval>")

    return "\n\n".join(blocks), total_diff_cnt, solution_hash


def ai_solve_step(trainset, messages, model="claude-3-5-sonnet-20241022", temperature=0.5, verbose=False):
    if verbose:
        print('User:')
        print(messages[0]['content'][0]['text'])
        print(f'Model: {model}')
        print(f'Temperature: {temperature}')

    # Initialize response
    assistant_answer = None

    # Handle Anthropic models
    if model.startswith('claude'):
        try:
            # Create fresh Anthropic client for each call
            anthropic_client = anthropic.Anthropic(
                api_key=ANTHROPIC_API_KEY,
            )

            message = anthropic_client.messages.create(
                model=model,
                max_tokens=1000,
                temperature=min(1, temperature),
                system="You are a bot that is very good at solving puzzles with python code.",
                messages=messages
            )
            assistant_answer = message.content[0].text
        except Exception as e:
          raise Exception(f"Anthropic API error: {str(e)}")

    # Handle OpenAI models gpt
    elif model.startswith('gpt'):
        try:
            openai_client = OpenAI(
                api_key=OPENAI_API_KEY
            )
            # Convert Anthropic message format to OpenAI format
            openai_messages = []
            for msg in messages:
                content = msg['content'][0]['text'] if isinstance(msg['content'], list) else msg['content']
                openai_messages.append({
                    "role": msg['role'],
                    "content": content
                })

            response = openai_client.chat.completions.create(
                model=model,
                messages=openai_messages,
                temperature=temperature,
                max_tokens=1000
            )
            assistant_answer = response.choices[0].message.content
        except Exception as e:
            raise Exception(f"OpenAI API error: {str(e)}")

    # Handle OpenAI models o1
    elif model.startswith('o1'):
        try:
            openai_client = OpenAI(
                api_key=OPENAI_API_KEY
            )
            # Convert Anthropic message format to OpenAI format
            openai_messages = []
            for msg in messages:
                content = msg['content'][0]['text'] if isinstance(msg['content'], list) else msg['content']
                openai_messages.append({
                    "role": msg['role'],
                    "content": content
                })

            response = openai_client.chat.completions.create(
                model=model,
                messages=openai_messages,
                # temperature=temperature,
                # max_completion_tokens=1000
            )
            assistant_answer = response.choices[0].message.content
        except Exception as e:
            raise Exception(f"OpenAI API error: {str(e)}")
    else:
        raise ValueError(f"Unsupported model: {model}")

    if not assistant_answer:
        raise Exception("No response received from the model")

    # Update messages history
    messages = messages + [
        {
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": assistant_answer
                },
            ]
        }
    ]

    transform_code = extract_code_block(assistant_answer)
    if verbose:
        print('Assistant:')
        print(assistant_answer)

    eval_blocks, diff_score, solution_hash = build_eval_block(trainset, transform_code)
    return transform_code, diff_score, assistant_answer, solution_hash, messages


def ai_solve_init(trainset, model, temperature=0.5, verbose=False):
  messages = [
          {
              "role": "user",
              "content": [
                  {
                      "type": "text",
                      "text": f"""You are a bot that is very good at solving puzzles. Below is a list of input and output pairs with a pattern.
Identify the pattern in the training examples, then apply that pattern to the test input to give a final output.

Pattern Description:
- Input is a grid containing numbers
- Each cell is non-negative number 0-7
- Output is another grid that follows a pattern based on the input
- Input and Output grids might have different shapes
- Output = transform(Input) - goal is to find this transform
- The relationship between input and output grids needs to be discovered from examples
- Special attention should be paid to:
  * How values in input affect patterns in output
  * How positions in input map to positions in output
  * The role of zero vs non-zero values
  * Any repeating patterns or transformations
  * Spatial relationships between grids and cells
  * Relationships might involve geometrical shapes and forms patterns
  * Relationships might relate to the surrounding cells patterns foming squares, lines and other forms

Key Analysis Steps:
1. Study the dimensions of input and output grids.
2. Observe how values from input influence output.
3. Look for pattern repetition or transformation rules.
4. Identify special behaviors.
5. Understand position mapping between grids.
6. Note any consistent rules across all examples.

{build_examples_block(trainset)}

Think step-by-step before you write the output with python code. \
1. Think through Key Analysis Steps. \
2. Think through transformation pattern itself. \
3. Provide ONLY implementation for `def transform(inputgrid)` python code for the solution. \
Make sure not to use any external libraries. \
Do not run call the function, but only create it. \
Provide it as ```python[code]```. Make you complete solution with code and do not output anythign after that."""
                  },
                  # {
                  #     "type": "image",
                  #     "source": {
                  #         "type": "base64",
                  #         "media_type": "image/jpeg",
                  #         "data": challengeset2gridb64(trainset)
                  #     }
                  # },
              ]
          }
      ]

  return ai_solve_step(
      trainset=trainset,
      model=model,
      messages=messages,
      temperature=temperature,
      verbose=verbose
  )


def ai_population(trainset, max_size=16, verbose=False):
    member_index = 0
    diff_score = 1_000_000
    population = []
    unique_hashes = set()

    while member_index < max_size * 2 and len(population) < max_size and diff_score > 0:  # Extended attempts to find unique solutions
        start_time = time.time()
        if verbose or True:
            print(f'Building member {len(population)+1}/{max_size} (attempt {member_index+1})...')
        try:
            model = "o1-preview" if member_index % 4 == 0 and member_index > 0 else "claude-3-5-sonnet-20241022"
            transform_code, diff_score, assistant_answer, solution_hash, messages = ai_solve_init(
                trainset=trainset,
                model=model,
                verbose=verbose)
            duration = time.time() - start_time

            # Only add if hash is unique
            if solution_hash not in unique_hashes:
                unique_hashes.add(solution_hash)
                population.append({
                    "transform_code": transform_code,
                    "diff_score": diff_score,
                    "duration": duration,
                    "assistant_answer": assistant_answer,
                    "solution_hash": solution_hash
                })
                if verbose or True:
                    print(f'Member {len(population)}/{max_size} completed, diff score: {diff_score}, duration: {duration}s, hash: {solution_hash}')
            else:
                if verbose or True:
                    print(f'Duplicate solution found (hash: {solution_hash}), skipping...')
        except Exception as e:
            print(e)
        member_index += 1

    return population

def ai_solve(trainset, challenge, max_retry=8, verbose=False):
  if verbose:
    visualize_challenge(trainset)

  population = ai_population(trainset, max_retry, verbose)
  if len(population) < 1:
    return None, 0
  top_member = population[-1]
  diff_score = top_member["diff_score"]
  transform_code = top_member["transform_code"]
  member_index = len(population)

  if diff_score == 0:
    if verbose:
      print("Solved!")
      print(transform_code)
    ai_solution = run_transform(
        transform_code=transform_code,
        input_grid=challenge)
    if verbose:
      visualize_challenge([{'input': trainset[0]['input'], 'output': ai_solution}], prefix='Solution ')
    return ai_solution, member_index
  else:
    return None, member_index


def solve_by_sets(trainset, challenge, solution, verbose=False):
    visualize_challenge(trainset)
    ai_solution, attempt = ai_solve(
        trainset=trainset,
        challenge=challenge,
        verbose=verbose)
    print(f'Solution (attempt #{attempt}): {ai_solution}')
    assert ai_solution == solution
    visualize_challenge([{'input': challenge, 'output': ai_solution}], prefix='Challenge ')


def solve_by_index(index, verbose=False):
    trainset = challenges[challenge_ids[index]]['train']
    challenge = challenges[challenge_ids[index]]['test'][0]['input']
    solution = solutions[challenge_ids[index]][0]
    solve_by_sets(
        trainset=trainset,
        challenge=challenge,
        solution=solution,
        verbose=verbose
    )

try:
  if challenge_ids and challenges and solutions and len(challenges) > 0:
    solve_by_index(0)
  else:
    solve_by_sets(
      trainset=challenge0['train'],
      challenge=challenge0['test'][0]['input'],
      solution=solution0[0]
    )
except NameError:
  solve_by_sets(
    trainset=challenge0['train'],
    challenge=challenge0['test'][0]['input'],
    solution=solution0[0]
  )

"""The initial idea was that we could validate generated claims later. However, this proved inefficient, as the initial generation quality matters significantly. When trying to correct claims afterward, we only increase the likelihood of hallucination. It appears more effective to avoid poor decisions from the start and instead regenerate content when needed."""

# def ai_solve_improve(trainset, messages, transform_code, verbose=False):
#     eval_blocks, diff_score = build_eval_block(trainset, transform_code)

#     if diff_score:
#         return transform_code, messages, diff_score

#     messages_x = [
#         {
#             "role": "user",
#             "content": [
#                 {
#                     "type": "text",
#                     "text": f"""You are a bot that is very good at solving puzzles. Below is a list of input and output pairs with a pattern.
# Identify the pattern in the training examples, then apply that pattern to the test input to give a final output.

# Pattern Description:
# - Input is a grid containing numbers
# - Each cell is non-negative number 0-7
# - Output is another grid that follows a pattern based on the input
# - Input and Output grids might have different shapes
# - Output = transform(Input) - goal is to find this transform
# - The relationship between input and output grids needs to be discovered from examples
# - Special attention should be paid to:
#   * How values in input affect patterns in output
#   * How positions in input map to positions in output
#   * The role of zero vs non-zero values
#   * Any repeating patterns or transformations
#   * Spatial relationships between grids

# Key Analysis Steps:
# 1. Study the dimensions of input and output grids.
# 2. Observe how values from input influence output.
# 3. Look for pattern repetition or transformation rules.
# 4. Identify special behaviors.
# 5. Understand position mapping between grids.
# 6. Note any consistent rules across all examples.

# Think step-by-step before you write the output with python code. \
# 1. Think through Key Analysis Steps. \
# 2. Think through transformation pattern itself. \
# 3. Provide ONLY implementation for `def transform(inputgrid)` python code for the solution. \
# Make sure not to use any external libraries. \
# Do not run call the function, but only create it. \
# Provide it as ```python[code]```. Make you complete solution with code and do not output anythign after that.

# Solution:
# ```python
# {transform_code}
# ```

# Execution result:
# {build_eval_block(trainset, transform_code)}

# Instructions: Think step-by-step before you write the the fixed python code. \
# Study each eval sample. We want Expected Output Grid to be equal to Actual Output Grid.
# Note what is is wrong with Solution and what could be improved.
# Think through transformation pattern itself. \
# Provide ONLY implementation for `def transform(inputgrid)` python code for the solution. \
# Make sure not to use any external libraries. \
# Do not run call the function, but only create it. \
# Provide it as ```python[code]```. Make you complete solution with code and do not output anythign after that."""
#                 },
#             ]
#         }
#     ]

#     message = client.messages.create(
#         model="claude-3-5-sonnet-20241022",
#         max_tokens=1000,
#         temperature=0.5,
#         system="You are a bot that is very good at solving puzzles with python code.",
#         messages=messages_x,
#     )

#     messages_x = messages_x + [
#         {
#             "role": "assistant",
#             "content": [
#                 {
#                     "type": "text",
#                     "text": message.content[0].text
#                 },
#             ]
#         }
#     ]

#     transform_code = extract_code_block(message.content[0].text)
#     if verbose:
#       print(message.content[0].text)

#     eval_blocks, diff_score = build_eval_block(trainset, transform_code)
#     return transform_code, messages_x, diff_score

# step = 0
# max_steps = 5
# while step < max_steps and diff_score > 0:
#   print(f'Step {step+1}/{max_steps}, diff score: {diff_score}')
#   transform_code, messages, diff_score = ai_solve_improve(
#       trainset=challenge0['train'],
#       messages=messages,
#       transform_code=transform_code,
#       verbose=False)
#   if diff_score == 0:
#     print('SOLVED!')
#     ai_solution = run_transform(transform_code, challenge0['test'][0]['input'])
#     assert ai_solution == solution0[0]
#     visualize_challenge([{'input': challenge0['test'][0]['input'], 'output': ai_solution}], prefix='Challenge ')
#     break
#   else:
#     print(f'NOT SOLVED :(')
#   step += 1

# print(transform_code)

solve_by_index(5)

solve_by_index(31)

solve_by_index(22)

"""The agentic system cannot find a solution for this pattern. However, for a human, it is quite evident: all four-element squares form one group, while all three-element squares form another. Let’s see if a genetic approach could help."""

def create_parent_analysis_prompt(trainset, parent1, parent2):
    """Create prompt for LLM to analyze parent solutions including their evaluation results"""
    eval_blocks1, _, _ = build_eval_block(trainset, parent1['transform_code'])
    eval_blocks2, _, _ = build_eval_block(trainset, parent2['transform_code'])

    return f"""You are a bot that is very good at solving puzzles. \
Analyze these two attempted solutions and suggest an improved solution.

Solution 1 (diff_score: {parent1['diff_score']}):
```python
{parent1['transform_code']}
```

Solution 1 evaluation:
`````
{eval_blocks1}
`````

Assistant's reasoning for Solution 1:
`````
{parent1['assistant_answer']}
`````

Solution 2 (diff_score: {parent2['diff_score']}):
```python
{parent2['transform_code']}
```

Solution 2 evaluation:
`````
{eval_blocks2}
`````

Assistant's reasoning for Solution 2:
`````
{parent2['assistant_answer']}
`````

Study these solutions carefully and propose an improved solution that combines \
their strengths while addressing their weaknesses.
Think step-by-step about:
1. What each solution does correctly and incorrectly (based on evaluation results)
2. How to merge the successful parts of both approaches
3. How to fix the specific issues shown in the evaluation blocks
Provide ONLY the implementation for `def transform(inputgrid)` in python code."""


def get_llm_solution(trainset, parent1, parent2, verbose=False):
    """Get new solution from LLM based on parent analysis"""
    try:
        # Create custom messages for ai_solve_step including parent analysis
        messages = [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": create_parent_analysis_prompt(trainset, parent1, parent2)
                    }
                ]
            }
        ]

        transform_code, diff_score, assistant_answer, solution_hash, _ = ai_solve_step(
            trainset=trainset,
            messages=messages,
            verbose=verbose,
            temperature=0.7  # Higher temperature for more exploration
            # TODO: Add support for passing custom messages to ai_solve_step
        )

        return {
            "transform_code": transform_code,
            "diff_score": diff_score,
            "assistant_answer": assistant_answer,
            "solution_hash": solution_hash,
            "duration": (parent1["duration"] + parent2["duration"]) / 2  # Average duration
        }
    except Exception as e:
        if verbose:
            print(f"LLM analysis failed: {e}")
        return None

def generate_final_solution(best_solution, challenge, trainset, verbose=False):
    """Generate final solution if successful"""
    if best_solution["diff_score"] == 0:
        if verbose:
            print("Solved!")
            print(best_solution["transform_code"])
        ai_solution = run_transform(
            transform_code=best_solution["transform_code"],
            input_grid=challenge)
        if verbose:
            visualize_challenge([{'input': trainset[0]['input'], 'output': ai_solution}], prefix='Solution ')
        return ai_solution
    return None

def ai_solve_genetic_llm(trainset, challenge, population_size=4, generations_cnt=2, drop_rate=0.25, verbose=False):
    """Main hybrid genetic-LLM algorithm analyzing each pair with LLM"""
    if verbose:
        visualize_challenge(trainset)

    # Get initial population
    population = ai_population(trainset, population_size, verbose)
    if len(population) < 2:
        return None, 0

    best_solution = min(population, key=lambda x: x["diff_score"])

    for generation_index in range(generations_cnt):
        if verbose:
            print(f"\nGeneration {generation_index + 1}/{generations_cnt}")
            print(f"Best score so far: {best_solution['diff_score']}")

        # Sort population by fitness
        population.sort(key=lambda x: x["diff_score"])

        if best_solution["diff_score"] == 0:
            break

        # Keep the best solution
        best_individual = population[0]

        # Calculate how many elements to remove (20% of population)
        remove_count = int(len(population) * drop_rate)

        # Sort by diff_score and remove the last 20%
        population.sort(key=lambda x: x["diff_score"])
        population = population[:-remove_count] if remove_count > 0 else population

        # Shuffle the whole population and form pairs
        shuffled_population = population.copy()
        random.shuffle(shuffled_population)
        pairs = []
        for i in range(0, len(shuffled_population) - 1, 2):
            pairs.append((shuffled_population[i], shuffled_population[i + 1]))

        # If odd number in population, pair last one with random member
        if len(shuffled_population) % 2 != 0:
            random_partner = random.choice(shuffled_population[:-1])  # Choose from all except last
            pairs.append((shuffled_population[-1], random_partner))

        # Create new generation using LLM analysis of each pair
        new_population = [best_individual]  # Keep best solution (elitism)

        # Get LLM solution for each pair
        for parent1, parent2 in pairs:
            llm_child = get_llm_solution(trainset, parent1, parent2, verbose)
            if llm_child is not None:
                new_population.append(llm_child)

        # If we need more solutions to maintain population size
        while len(new_population) < population_size:
            extra_parent = random.choice(population)
            llm_child = get_llm_solution(trainset, best_individual, extra_parent, verbose)
            if llm_child is not None:
                new_population.append(llm_child)

        population = new_population[:population_size]

        # Update best solution
        current_best = min(population, key=lambda x: x["diff_score"])
        if current_best["diff_score"] < best_solution["diff_score"]:
            best_solution = current_best

    # Generate final solution
    solution = generate_final_solution(best_solution, challenge, trainset, verbose)
    return solution, len(population)

index = 22
verbose = True
trainset = challenges[challenge_ids[index]]['train']
challenge = challenges[challenge_ids[index]]['test'][0]['input']
solution = solutions[challenge_ids[index]][0]
visualize_challenge(trainset)
ai_solution, attempt = ai_solve_genetic_llm(
    trainset=trainset,
    challenge=challenge,
    verbose=verbose)
print(f'Solution (attempt #{attempt}): {ai_solution}')
assert ai_solution == solution
visualize_challenge([{'input': challenge, 'output': ai_solution}], prefix='Challenge ')

"""Aprerently, combining pairs didn't solve the challenge."""

def create_population_analysis_prompt(trainset, population):
    """Create prompt for LLM to analyze all solutions in the population"""
    solution_blocks = []

    for i, solution in enumerate(population, 1):
        eval_blocks, _, _ = build_eval_block(trainset, solution['transform_code'])
        solution_blocks.append(f"""Solution {i} (diff_score: {solution['diff_score']}):
```python
{solution['transform_code']}
```

Solution {i} evaluation:
`````
{eval_blocks}
`````

Assistant's reasoning for Solution {i}:
`````
{solution['assistant_answer']}
`````
""")

    solutions_text = "\n".join(solution_blocks)

    return f"""You are a bot that is very good at solving puzzles. \
Analyze these {len(population)} attempted solutions and suggest an improved solution.

{solutions_text}

Study all these solutions carefully and propose an improved solution that combines \
their collective strengths while addressing their weaknesses.
Think step-by-step about:
1. What each solution does correctly and incorrectly (based on evaluation results)
2. How to merge the successful parts from multiple approaches
3. How to fix the specific issues shown in the evaluation blocks
4. Which solutions have the most promising approaches
Provide ONLY the implementation for `def transform(inputgrid)` in python code."""

def get_llm_solution_from_population(trainset, population, verbose=False):
    """Get new solution from LLM based on analysis of entire population"""
    try:
        messages = [
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": create_population_analysis_prompt(trainset, population)
                    }
                ]
            }
        ]

        transform_code, diff_score, assistant_answer, solution_hash, _ = ai_solve_step(
            trainset=trainset,
            messages=messages,
            verbose=verbose,
            temperature=0.7
        )

        return {
            "transform_code": transform_code,
            "diff_score": diff_score,
            "assistant_answer": assistant_answer,
            "solution_hash": solution_hash,
            "duration": sum(p["duration"] for p in population) / len(population)  # Average duration
        }
    except Exception as e:
        if verbose:
            print(f"LLM population analysis failed: {e}")
        return None

def ai_solve_genetic_llm(trainset, challenge, population_size=4, generations_cnt=2, drop_rate=0.25, verbose=False):
    """Main hybrid genetic-LLM algorithm analyzing entire population"""
    if verbose:
        visualize_challenge(trainset)

    # Get initial population
    population = ai_population(trainset, population_size, verbose)
    if len(population) < 2:
        return None, 0

    best_solution = min(population, key=lambda x: x["diff_score"])

    for generation_index in range(generations_cnt):
        if verbose:
            print(f"\nGeneration {generation_index + 1}/{generations_cnt}")
            print(f"Best score so far: {best_solution['diff_score']}")

        # Sort population by fitness
        population.sort(key=lambda x: x["diff_score"])

        if best_solution["diff_score"] == 0:
            break

        # Keep the best solution
        best_individual = population[0]

        # Remove weakest solutions
        remove_count = int(len(population) * drop_rate)
        population = population[:-remove_count] if remove_count > 0 else population

        # Create new generation using LLM analysis of entire population
        new_population = [best_individual]  # Keep best solution (elitism)

        # Generate multiple solutions from population analysis
        remaining_slots = population_size - len(new_population)
        for _ in range(remaining_slots):
            llm_child = get_llm_solution_from_population(trainset, population, verbose)
            if llm_child is not None:
                new_population.append(llm_child)

        population = new_population[:population_size]

        # Update best solution
        current_best = min(population, key=lambda x: x["diff_score"])
        if current_best["diff_score"] < best_solution["diff_score"]:
            best_solution = current_best

    # Generate final solution
    solution = generate_final_solution(best_solution, challenge, trainset, verbose)
    return solution, len(population)


index = 22
verbose = True
trainset = challenges[challenge_ids[index]]['train']
challenge = challenges[challenge_ids[index]]['test'][0]['input']
solution = solutions[challenge_ids[index]][0]
visualize_challenge(trainset)
ai_solution, attempt = ai_solve_genetic_llm(
    trainset=trainset,
    challenge=challenge,
    verbose=verbose)
print(f'Solution (attempt #{attempt}): {ai_solution}')
assert ai_solution == solution
visualize_challenge([{'input': challenge, 'output': ai_solution}], prefix='Challenge ')